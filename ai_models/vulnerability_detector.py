import os
import re
import torch
import torch.nn.functional as F
from transformers import AutoTokenizer, AutoModelForSequenceClassification
from graphviz import Digraph
import base64

class SmartContractVulnerabilityDetector:
    def __init__(self, model_dir=None):
        if model_dir is None:
            model_dir = os.path.join("models", "codebert_classifier")

        self.tokenizer = AutoTokenizer.from_pretrained("microsoft/codebert-base")
        self.model = AutoModelForSequenceClassification.from_pretrained(model_dir)
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model.to(self.device)

    def predict(self, contract_code: str):
        inputs = self.tokenizer(contract_code, return_tensors="pt", truncation=True, padding=True)
        inputs = {k: v.to(self.device) for k, v in inputs.items()}

        with torch.no_grad():
            outputs = self.model(**inputs)
            logits = outputs.logits
            probabilities = F.softmax(logits, dim=1).squeeze()
            pred_class = torch.argmax(probabilities).item()

        is_vulnerable = pred_class == 1
        confidence = round(probabilities[pred_class].item(), 4)

        result = {
            "is_vulnerable": is_vulnerable,
            "confidence": confidence,
            "vulnerability_type": "None Detected",
            "risk_level": "Low",
            "reason": "No critical security concern identified.",
            "recommendation": "No action required.",
            "vulnerable_code": "// No vulnerable pattern detected.",
            "risk_diagram": "https://upload.wikimedia.org/wikipedia/commons/b/b2/Attack_Surface_Model.svg",
            "prevention_methods": [],
            "reference_links": []
        }

        if is_vulnerable:
            # ✅ Use broader regex to catch `.call{value: ...}()` too
            vulnerable_snippet = self.extract_vulnerable_snippet(contract_code, r"(call\.value|\.call\s*\(|call\s*\{.*\})")

            # ✅ Generate Graphviz risk diagram (inline SVG)
            svg_diagram = self.generate_risk_diagram("Potential Reentrancy")

            result.update({
                "vulnerability_type": "Potential Reentrancy",
                "risk_level": "High",
                "reason": "The contract allows external calls before internal state updates, which can be exploited.",
                "recommendation": "Use Checks-Effects-Interactions pattern or ReentrancyGuard from OpenZeppelin.",
                "vulnerable_code": vulnerable_snippet,
                "risk_diagram": svg_diagram,  # ✅ inline SVG replaces static URL
                "prevention_methods": [
                    "Apply the Checks-Effects-Interactions pattern.",
                    "Use ReentrancyGuard from OpenZeppelin.",
                    "Avoid unguarded use of `.call()` or `call.value()`.",
                    "Perform manual reviews and static analysis with tools like Slither, MythX."
                ],
                "reference_links": [
                    "https://docs.openzeppelin.com/contracts",
                    "https://consensys.github.io/smart-contract-best-practices/",
                    "https://github.com/crytic/slither"
                ]
            })

        return result

    def extract_vulnerable_snippet(self, code: str, pattern: str):
        lines = code.split("\n")
        for i, line in enumerate(lines):
            if re.search(pattern, line):
                return f"Line {i+1}: {line.strip()}"  # ✅ include line number
        return "// Vulnerable code could not be isolated."

    def generate_risk_diagram(self, vuln_type: str) -> str:
        dot = Digraph(comment="AI Risk Flow")
        if vuln_type == "Potential Reentrancy":
            dot.attr(rankdir='LR')
            dot.node("User", "🔓 External User")
            dot.node("Contract", "⚙️ Contract")
            dot.node("Withdraw", "💸 Withdraw Function")
            dot.node("Exploit", "🔁 Reentrant Call")
            dot.edges([
                ("User", "Contract"),
                ("Contract", "Withdraw"),
                ("Withdraw", "Exploit"),
                ("Exploit", "Withdraw")
            ])
        # Convert to inline SVG string
        svg = dot.pipe(format="svg").decode("utf-8")
        return svg
